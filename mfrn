#!/usr/bin/env python3

# ****************************************************************************
# DESCRIPTION
#   Simple file mass renaming. Please see usage for further details.
#
# bugs and hints: lrsklemstein@gmail.com
# ****************************************************************************


import glob
import math
import os.path
import shutil
import sys


def main():
    setup = get_setup_or_exit_with_usage()

    moved = rename_files_by_template(setup)
    eprint(f'Done (moved {moved} file(s)).')

    sys.exit(0)


def print_usage_and_exit(rc: int = 2):
    progname = os.path.basename(sys.argv[0])

    usage = (
        '\n'
        'mfrn == mass file renamer\n'
        '\n'
        f'usage: {progname} DIR template [source_pattern]\n'
        '\n'
        '           DIR  ->  directory to operate on (e.g. "." or "~/mydir")\n'
        '      template  ->  define the new filename scheme, '
        'use %d for numbering\n'
        '                    (e.g.  "myfile_%d.txt")\n'
        'source_pattern  ->  optional glob pattern for files '
        'to be renamed, default is *\n'
    )

    eprint(usage)
    sys.exit(2)


def eprint(m: str):
    print(m, file=sys.stderr)


def get_setup_or_exit_with_usage() -> dict[str, str]:
    if not 3 <= len(sys.argv) <= 4:
        print_usage_and_exit()

    setup = {
        'dir': sys.argv[1],
        'template': sys.argv[2],
        'source_pattern': sys.argv[3] if len(sys.argv) == 4 else '*',
    }

    if '%d' not in setup['template'] or \
            setup['template'].index('%d') != setup['template'].rindex('%d'):
        eprint('template string must contain exactly one occurence of "%d"')
        sys.exit(1)

    return setup


def rename_files_by_template(setup: dict[str, str]):
    file_list = get_file_list_or_exit(setup)
    return move_files(file_list)


def get_file_list_or_exit(setup: dict[str, any]) -> list[str, str, str]:
    file_list = make_initial_file_list(setup)

    exit_on_empty_file_list(file_list, setup['source_pattern'])

    numwidth = int(math.log(len(file_list), 10)) + 1

    template = setup['dir'] + os.path.sep + \
        setup['template'].replace('%d', f'%0{numwidth}d')

    for n, file_names in enumerate(file_list, start=1):
        file_real, file_tmp_active = file_names[:]
        file_dest = template % n
        file_names.append(file_dest)

    return file_list


def make_initial_file_list(setup: dict[str, any]) -> list[str, str]:
    file_list = list()
    glob_pattern = setup['dir'] + os.path.sep + setup['source_pattern']

    for file in glob.glob(glob_pattern):
        if os.path.isdir(file):
            continue

        file_tmp_active = file + '.__tmp_active__'
        file_list.append([file, file_tmp_active])

    file_list.sort()

    return file_list


def exit_on_empty_file_list(
            file_list: list[str, str, str], source_pattern: str):
    if len(file_list) == 0:
        if source_pattern == '*':
            eprint('No files found!')
        else:
            eprint('No matching files found!')
        sys.exit(0)


def move_files(file_list: list[str, str, str]) -> int:
    """we move to a temporily name before moving to dest, because
    so we get rid off problems due conflicting existing file names,
    .e.g. due conflicts after incomplete further runs etc.
    At least I hope so...
    """
    for n, file_names in enumerate(file_list, start=1):
        file_real, file_tmp_active, file_dest = file_names[:]

        # when e.g. executed twice on the same file set the destination
        # file might already exist with the desired name
        if file_real != file_dest:
            shutil.move(file_real, file_tmp_active)

    moved = 0
    for n, file_names in enumerate(file_list, start=1):
        file_real, file_tmp_active, file_dest = file_names[:]

        if file_real == file_dest:
            eprint(f'  [{n}] no action required for {file_dest}')
        else:
            eprint(f'  [{n}] {file_real} -> {file_dest}')
            shutil.move(file_tmp_active, file_dest)
            moved += 1

    return moved


if __name__ == '__main__':
    main()
