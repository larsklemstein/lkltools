#!/bin/bash -eu

# ****************************************************************************
# DESCRIPTION
#   Staffold a simple python3 program incl. argparse and logging
#
#
# Todo: create a sample logging ini
#
# bugs and hints: lrsklemstein@gmail.com
# ****************************************************************************

readonly PROG=${0##*/}


msg() {
    echo "$*" >&2
}

abort() {
    msg "$*"
    exit 1
}

if [ $# -ne 1 ]
then
    echo "Usage: $PROG PYPROG" >&2
    exit 2
fi

pyprog="$1"

if [ -f "$pyprog" ]
then
    abort "\"$pyprog\" already exist"
fi

email=$(git config --global user.email 2>/dev/null) || true
[ -n "$email" ] || email="<unknown>"

/bin/cat >$pyprog <<EOF
#!/usr/bin/env python3

# ****************************************************************************
# DESCRIPTION
#   Does this and that. And much mure.

# bugs and hints: ${email}
# ****************************************************************************

import argparse
import logging
import sys


__log_level_default = logging.INFO


def main():
    setup = get_prog_setup_or_exit_with_usage()  # might exit with rc=2
    init_logging(setup)

    logger = logging.getLogger(__name__)

    try:
        run(setup)
    except Exception:
        logger.critical('Abort, rc=3', exc_info=True)
        sys.exit(3)

    sys.exit(0)


def get_prog_setup_or_exit_with_usage() -> dict[str, any]:
    parser = argparse.ArgumentParser(
        description=(
            'Some words about what your program actually does'
        )
    )

    log_group = parser.add_mutually_exclusive_group()

    parser.add_argument(
        'FIX_ARG_EXAMPLE', help='FIX_ARG is for, well: please say it',
    )

    parser.add_argument(
        '--optional_arg', help='an example for an optional arg',
    )

    log_group.add_argument(
        '--debug', action='store_true',
        help='enable debug log level',
    )

    log_group.add_argument(
        '--log_cfg', dest='log_cfg',
        help='optional logging cfg in ini format',
    )

    args = vars(parser.parse_args())
    args = {k: '' if v is None else v for k, v in args.items()}

    return args


def init_logging(setup: dict[str, any]) -> None:
    """Creates either a logger by cfg file or a default instance
    with given log level by arg --log_level (otherwise irgnored)

    """
    if setup['log_cfg'] == '':
        if setup['debug']:
            level = logging.DEBUG
            format = '%(levelname)s - %(message)s'
        else:
            level = __log_level_default
            format = '%(message)s'

        logging.basicConfig(level=level, format=format)
    else:
        logging.config.fileConfig(setup['log_cfg'])


def run(setup: dict[str, any]) -> None:
    logger = logging.getLogger(__name__)

    #
    # this is the entry point for what your program actually does...
    # 

    logger.info(f'Done something...')


if __name__ == '__main__':
    main()
EOF

chmod +x $pyprog

msg "Created $pyprog"

/bin/cat >&2 << EOF

Hints:

- please adjust get_prog_setup_or_exit_with_usage() as this defines the
  arguments (fixed and optional) your program expect.

- default log log level when not using a logging cfg is defined in program
  header in __log_level_default (=logging.INFO). So if you want to create a unix like
  ("no message is a good message") style program, just set this to e.g. logging.WARNING.
  Default basic logging output is just text (no log level, no date etc.).

- normally you do not need to touch main() and init_logging() at all.

- the entry point for all your high level code is run() (called by main() in an
  exception clause to catch critical errors).

EOF
