#!/bin/bash -eu

# ****************************************************************************
# DESCRIPTION
#   Staffold a simple python3 program incl. argparse and logging
#
#
# Todo: create a sample logging ini
#
# bugs and hints: lrsklemstein@gmail.com
# ****************************************************************************


# ----------------------------------------------------------------------------
# constants
# ----------------------------------------------------------------------------

readonly PROG=${0##*/}

SHORT_USAGE="$PROG [-h] [-e] [-f] [-d description] "
SHORT_USAGE+="[-r role] [-l LOG_INI] PYPROG" 
readonly SHORT_USAGE

readonly ENTRY_COMMENT="
    #
    # this is the entry point for what your program actually does...
    #
"

# ----------------------------------------------------------------------------
# defaults
# ----------------------------------------------------------------------------
#
shebang='#!/usr/bin/env python3'

dict_str_any='Dict[str, Any]'

log_ini=
edit=n
force_mode=n
old_version=n
role=example

description="WHat's the blue light for?

It light's blue..."

setup_getter='setup = get_prog_setup_or_exit_with_usage()'

rc_ok=0
rc_usage=2
rc_exception=3


# ----------------------------------------------------------------------------
# functions
# ----------------------------------------------------------------------------

print_short_usage_and_exit() {
    echo "Usage: $SHORT_USAGE" >&2
    exit 2
}

print_long_usage_and_exit() {
/bin/cat >&2 << EOF
mkpy = make python program

A simple tool to create a new python program in a unique way.

base usage:

$SHORT_USAGE

options:



EOF

exit 2
}

msg() {
    echo "$*" >&2
}

abort() {
    msg "$*"
    exit 1
}

ap_fix_args_example() {
/bin/cat << EOF
    parser.add_argument(
        'FIX_ARG_EXAMPLE', help='FIX_ARG is for, well: please say it',
    )
EOF
}

ap_fix_args_inout() {
/bin/cat << EOF
    parser.add_argument(
        'infile', metavar='INFILE', type=str, help='input file',
    )

    parser.add_argument(
        'outfile', metavar='OUTFILE', type=str, help='output file',
    )
EOF
}

get_run_func() {
    dict_str_any=${1:-$default_dict_str_any}

/bin/cat <<EOF
def run(setup: ${dict_str_any}) -> int:
    logger = logging.getLogger(__name__)
${ENTRY_COMMENT}
    logger.info('Done something...')

    return ${rc_ok}
EOF
}

setup_getter_nagios() {
/bin/cat <<EOF
    try:
        setup = get_prog_setup_or_exit_with_usage()
    except:
        sys.exit(2)
EOF
}

# ----------------------------------------------------------------------------
# main
# ----------------------------------------------------------------------------



while getopts efnv:d:r:l:h opt
do
    case $opt in
        e)
            edit=y ;;
        f) 
            force_mode=y ;;
        d)
            description=$OPTARG ;;
        r)
            role=$OPTARG ;;
        l)
           log_ini=$OPTARG ;;
        h)
            print_long_usage_and_exit ;;
        *)
            print_short_usage_and_exit ;;
    esac
done

case $role in
    example)
        fix_args=$(ap_fix_args_example) ;;
    inout|in_out)
        fix_args=$(ap_fix_args_inout) ;;
    nagios|nagios?plugin)
        fix_args=$(ap_fix_args_inout) ;;
    *)
        msg "unknown role \"$role\" specified"
        exit 2
esac

shift $((OPTIND-1))

[ $# -eq 1 ] || print_short_usage_and_exit

pyprog="$1"

if [ -f "$pyprog" -a "$force_mode" = n ]
then
    abort "\"$pyprog\" already exist"
fi

email=$(git config --global user.email 2>/dev/null) || true
[ -n "$email" ] || email="<unknown>"


run_func=$(get_run_func "$dict_str_any")

/bin/cat >$pyprog <<EOF
${shebang}

"""
${description}
"""

# bugs and hints: ${email}

import argparse
import logging
import logging.config
import sys

from typing import Any, Dict  # , List, Tuple, Callable

__log_level_default = logging.INFO


def main():
    ${setup_getter}

    init_logging(setup)
    logger = logging.getLogger(__name__)

    try:
        sys.exit(run(setup))
    except Exception:
        logger.critical("Abort, rc=${rc_exception}", exc_info=True)
        sys.exit(${rc_exception})


def get_prog_setup_or_exit_with_usage() -> ${dict_str_any}:
    parser = argparse.ArgumentParser(
                description=get_prog_doc(),
                formatter_class=argparse.RawTextHelpFormatter,
            )

    log_group = parser.add_mutually_exclusive_group()

${fix_args}

#   parser.add_argument(
#        '--optional_arg', help='an example for an optional arg',
#   )

    log_group.add_argument(
        '--debug', action='store_true',
        help='enable debug log level',
    )

    log_group.add_argument(
        '--log_cfg', dest='log_cfg',
        help='optional logging cfg in ini format',
    )

    args = vars(parser.parse_args())
    args = {k: '' if v is None else v for k, v in args.items()}

    return args


def get_prog_doc() -> str:
    doc_str = sys.modules['__main__'].__doc__

    if doc_str is not None:
        return doc_str.strip()
    else:
        return '<???>'


def init_logging(setup: $dict_str_any) -> None:
    """Creates either a logger by cfg file or a default instance
    with given log level by arg --log_level (otherwise irgnored)

    """
    if setup['log_cfg'] == '':
        if setup['debug']:
            level = logging.DEBUG
            format = '%(levelname)s - %(message)s'
        else:
            level = __log_level_default
            format = '%(message)s'

        logging.basicConfig(level=level, format=format)
    else:
        logging.config.fileConfig(setup['log_cfg'])


${run_func}


if __name__ == '__main__':
    main()
EOF

chmod +x $pyprog

msg "Created $pyprog"

if [ $edit = y ]
then
    editor=${EDITOR:-vi}

    if egrep -q "$editor" <<< '^(n?vi|n?vim)$'
    then
        p="logger\.info.*'Done something"
        typeset -i run_pos=$(grep -n "$p" $pyprog  | cut -d: -f1)
        run_pos=run_pos-1
        $editor +$run_pos $pyprog
    else
        $editor $pyprog
    fi
fi
